Parsing:
- scalar/array/void context
  - some binary operators do not force scalar context (assignment)
  - prototypes
  - splice/substr/lvalue subroutines
- &foo; vs. &foo() vs. foo()
  - show the difference in syntax tree
  - &foo passes @_ to callee
  - &foo() bypasses prototype
  - foo() is plain call
  - &$foo() is plain call (just with deref)
  - \&foo takes reference, \&foo->() calls foo, takes reference of the result
    and calls it
- stashes
- global variables/symbols (STDOUT!)
- local variables
- scoping
- lexing of quoted strings
- conditional constructs
- do/require/use/eval
- undef
- garbage collection
- labels
- subroutine prototypes
  - parsing
  - context propagation
- scope handling of conditional/while/continue
- handle errors
- handling of parse errors with recovery
- strictures
- lexical pragmas/hints
- handle :: in identifiers, ${^foo} special variables, "'" in identifiers
- proper lexing of ${  id # comment\n } vs. ${ id # comment \n expr }
- proper check for overridable builtins (only if imported)
- builtins overridable using CORE::GLOBAL
- CORE::builtin to always call builtin
- special treatment for glob()
- simplify detection of <foo> vs. <foo >, avoid constructing a lexer
- packages
- package handling in our()
- parsing of nullary/unary vs. list operators
- => must also quote qw/qx/s/etc.
- quoting inside ->{}, also of {s}, etc.
- \Q\L\U\E in quoted strings/patterns
- regexp
  - char classes and other metacharacters
  - backreferences, also in substitution
  - magic variables
  - (?...) syntax and grouping
  - empty pattern
  - flags
  - context-dependent bexaviour
  - always a pattern after =~/!~
- intuit_more, esp. inside patterns
- \xaf, \011,etc when lexing quoted strings

Runtime:
- integer -> float on overflow (also in parsing!)
- proper scalar polimorphing
  - mixed-mode arithmetic
- proper handling of function return values
  - implicit return
  - context
- encapsulate lexical lookup/closure
- better handling of sub calls
  - encapsulate enter/leave
- proper morphing on scalar assignment
- autovivification
- create common superclass for reference/scalar
- multiple dispatch operators
- array/list/hash assignment
  - optimize lists with common assignments
  - check mixed assignments

Refactoring:
- check offsets for call sequence, refactor stack handling
- proper handling of bytecode
- replace all strings with integer constants/flags
  - move lexer/parser constants to a separate module from runtime ones
  - move information about bultins/overridables to a separate module
    (currently in both lexer and parse-tree)
- remove dependency from parser to implementation (::Values, scratchpad)
- assert unlexed tokens are relexed with the correct expectations
- assert lex_string/lex unlex buffers do not intermingle
- separate compile-time lexicals from run-time scratchpads
- make regexp parser a full blown parser, not the hack it is;
  add a lexer subclass for parsing patterns
- fold _parse_maybe_subscripts into its only caller
- rationalize the special cases for slices, &foo function calls,
  subscripts, dereferences
