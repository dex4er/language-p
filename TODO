- proper handling of bytecode
- proper scalar polimorphing
- proper handling of function return values
- scalar/array/void context
- stashes
- global variables/symbols (STDOUT!)
- local variables
- scoping
- lexing of quoted strings
- conditional constructs
- lexing of integers/floating point
- do/require/use/eval
- multiple dispatch operators
- array/list/hash assignment
  - optimize lists with common assignments
- undef
- garbage collection
- remove dependency from parser to implementation (::Values, scratchpad)
- labels
- subroutine prototypes
- scope handling of conditional/while/continue
- handle errors
- encapsulate lexical lookup/closure
- better handling of sub calls
  - encapsulate enter/leave
- proper morphing on scalar assignment
- autovivification
- create common superclass for reference/scalar
- handling of parse errors with recovery
- strictures
- lexical pragmas/hints
- assert unlexed tokens are relexed with the correct expectations
- assert lex_string/lex unlex buffers do not intermingle
- handle :: in identifiers, ${^foo} special variables, "'" in identifiers
- proper lexing of ${  id # comment\n } vs. ${ id # comment \n expr }
- proper check for overridable builtins (only if imported)
- special treatment for glob()
- simplify detection of <foo> vs. <foo >
- quote-like operators (qw, qx, ...)
- for, foreach
